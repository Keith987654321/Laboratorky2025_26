'''
    Быстрая сортировка берёт эл-т по середине массива, как опорный,
	и сравнивает остальные эл-ты с ним. По окончании работы функции
	partOfQuickSort все эл-ты слева от опорного должны быть <= ему,
	а все эл-ты справа >= опорного. Таким образом мы разбили массив
	на 2 подмассива - меньшый (левый) и больший (правый). Потом
	с помощью рекурсии мы запускаем тот же алгоритм уже отдельно
	для каждого подмассива и алгоритм повторяется, пока длина подмассивов
	не станет равна 1. Когда длины всех подмассивов = 1, то исходный
	массив считается отсортированным.
'''

def partition(arr, left, right):
    pivot = arr[(left + right) // 2] # Запоминаем опорный эл-т
    while left <= right: # Сортируем подмассивы, пока указатели left и right не пересекутся друг с другом
        while arr[left] < pivot: # Двигаем указатель left вправо, пока не найдём эл-т больше опорного
            left += 1
        while arr[right] > pivot: # Двигаем right, пока не найдём эл-т меньше опорного
            right -= 1

        if left <= right:
            arr[left], arr[right] = arr[right], arr[left] # Меняем эл-ты в нужные подмассивы
            left += 1
            right -= 1
    return left # По окончанию ф-ции указатель left указывает на начало правого (большего) подмассива


def quick_sort(arr, start, end):
    if start >= end: # Условие выхода из рекурсии
        return

    right_start = partition(arr, start, end) # Делим массив на 2 подмассива
    quick_sort(arr, start, right_start - 1)  # Рекурсивно сортируем левый подмассив
    quick_sort(arr, right_start, end)        # и правый


def sort(arr):
    quick_sort(arr, 0, len(arr) - 1)



arr = [4, 7, 2, 5, 9, 4, 3]
sort(arr)
print(arr)
